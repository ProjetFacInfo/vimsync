set nocompatible                " Disable vi compatiblity

"===================
"=== XDG SUPPORT ===
"===================
if empty($MYVIMRC) | let $MYVIMRC = expand('<sfile>:p') | endif

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p', 0700)
set viewdir=$XDG_DATA_HOME/vim/view | call mkdir(&viewdir, 'p', 0700)

set backupdir=$XDG_CACHE_HOME/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$XDG_CACHE_HOME/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$XDG_CACHE_HOME/vim/undo     | call mkdir(&undodir,   'p', 0700)

if !has('nvim') | set viminfofile=$XDG_CACHE_HOME/vim/viminfo | endif

"================
"=== vim-plug ===
"================

" Automatically install vimplug if not installed
let data_dir = '$XDG_CONFIG_HOME/vim'
if empty(glob(data_dir . '/autoload/plug.vim'))
	silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
	autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Install my plugins
call plug#begin('$XDG_DATA_HOME/vim/plugged')

" Polyglot decides to mess with tab settings for whatever reason
" let g:polyglot_disabled = ['autoindent']
Plug 'sheerun/vim-polyglot'
Plug 'vim-scripts/dbext.vim'
Plug 'elkowar/yuck.vim'
Plug 'dracula/vim',{ 'as' : 'dracula' }
Plug 'itchyny/vim-cursorword'
Plug 'junegunn/goyo.vim'

" Auto Complete
Plug 'lifepillar/vim-mucomplete'

" Search file
Plug 'junegunn/fzf.vim'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }

" Taglist
Plug 'majutsushi/tagbar', { 'on': 'TagbarOpenAutoClose' }

" Snippits
Plug 'SirVer/ultisnips'  , { 'for': ['vim-plug', 'python', 'cpp', 'c','css', 'html', 'sql', 'javascript', 'php', 'sh'] }
Plug 'honza/vim-snippets', { 'for': ['vim-plug', 'python', 'cpp', 'c','css', 'html', 'sql', 'javascript', 'php', 'sh'] }

" Buffers, workflow
Plug 'itchyny/lightline.vim'
Plug 'mengelbrecht/lightline-bufferline'
Plug 'justinmk/vim-dirvish'
Plug 'Konfekt/FastFold'

" Text operations/manipulation
Plug 'LunarWatcher/auto-pairs'
Plug 'wellle/targets.vim'
Plug 'justinmk/vim-sneak'
Plug 'gcmt/wildfire.vim' " in Visual mode, type i' to select all text in '', or type i) i] i} ip
Plug 'tpope/vim-surround'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-repeat'
Plug 'tommcdo/vim-lion'
Plug 'tommcdo/vim-exchange'
Plug 'mbbill/undotree'
Plug 'tomtom/tcomment_vim'
Plug 'preservim/vim-pencil'
Plug 'terryma/vim-multiple-cursors'

" HTML, CSS, JavaScript, PHP, JSON, etc.
Plug 'gko/vim-coloresque', { 'for': ['vim-plug', 'php', 'html', 'javascript', 'css'] }
Plug 'mattn/emmet-vim', { 'for': [ 'html', 'css', 'php', 'javascript' ] }

" Bookmarks
Plug 'kshenoy/vim-signature'

call plug#end()

runtime! macros/matchit.vim

"================
"=== Settings ===
"================
" If you want to know what each setting does you can do :h <setting name>

let loaded_netrw = 1
let loaded_netrwPlugin = 1      "netrw -> ðŸ—‘

filetype on
filetype indent on
filetype plugin on
filetype plugin indent on

set encoding=utf-8

set ttyfast lazyredraw
set updatetime=750

set clipboard=unnamedplus

set hidden

set scrolloff=5 sidescrolloff=5

set shortmess=a
set title
set number relativenumber

set grepprg=rg\ --vimgrep\ --smart-case\ --follow

" Search
set ignorecase smartcase
if has('extra_search')
	set hlsearch incsearch
endif

if has('cmdline_info')
	set ruler showcmd
endif

" Spelling correction
if has('syntax')
	syntax on
	set nospell
	set spelllang=fr
	set cursorline
endif

" Changes cursor shape in different modes
" set Vim-specific sequences for RGB colors and enable truecolor support
if $TERM ==# "st-256color" && has('termguicolors')
	let &t_SI = "\<Esc>[6 q"
	let &t_SR = "\<Esc>[4 q"
	let &t_EI = "\<Esc>[2 q"
	let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
	let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
	set termguicolors
elseif $TERM !=# "st-256color" && has('termguicolors')
	set termguicolors
endif

" Tab complete for fuzzy finding
if has('wildmenu')
	set wildmenu wildignorecase wildmode=longest:list,full
	if has('wildignore')
		" set wildoptions=pum
		set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.jpe,*.png,*.webp,*.svg
		set wildignore+=*.pdf,*.psd,*.epub,*.ps,*.djvu,*.mobi
		set wildignore+=*.word,*.ods,*.docx,*.odt,*.doc,*.xlsx
		set wildignore+=*.wav,*.mp3,*.flac,*.opus,*.m3u,*.ogg
		set wildignore+=*.mp4,*.mkv,*.webm,*.m4a
		set wildignore+=*.o,*.obj,*.out
		set wildignore+=*/,
		set wildignore+=node_modules/*,bower_components/*
	endif
endif

" Code safety
if has('persistent_undo')       " You can undo changes across sessions
	set undolevels=5000
	set autowriteall undofile autoread
else
	echom "Your system doesn't support persistent undo ! Be careful !"
endif
set updatecount=10

" Project navigation, open vim in the root dir of your project and then
" Use find <filename> to open new buffer with the filename.
" This is neat but I prefer to use e */**<file> since it has better fuzzy
" finding (look at my binding)
" the benefit of find is that it is not relative to your current directory
if has('path_extra')
	set path=$PWD/**
endif

" Folds
if has('folding')
	if (&ft == '')
		set foldmethod=manual
	else
		set foldmethod=syntax
	endif

	set foldnestmax=1
	set foldlevelstart=20
	set foldminlines=0

	" Toggle overview mode (close or open all folds)
	" Mapped to <leader>o (look at mappings)
	function ToggleOverview()
		if &foldlevel > 0
			let b:tmp = &foldlevel
			let &l:foldlevel = 0
		else
			let &l:foldlevel = b:tmp
		endif
	endfunction
endif

" Indentation
filetype plugin indent on
if has('smartindent')
	set autoindent smartindent
else
	set autoindent
endif

" I use the smarttabs plugin so TABS are used to indent at the start of
" lines and spaces are used to align stuff like comments you get the
" best of both worlds ; user customizable indentation and consistent alignment
set tabstop=4
set shiftwidth=0
set noexpandtab

" ===
" === Restore Cursor Position
" ===
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" This function converts the file that I'm editing to my prefferd tabs and
" spaces 'format'.
" To use this function place your cursor on a line with 1 level of indentation!
" because the function needs to know how many spaces = 1 level of indentation
" to be able to convert them back to tabs
function FixTabsAndSpaces()
	" We convert all the tabs to spaces
	set expandtab
	retab

	" We figure out the size of 1 level of indentation
	let faketabsize = indent(line("."))
	let l:tmp = &l:tabstop
	let &l:tabstop = faketabsize

	" Convert the spaces back into tabs only at the start of lines
	set noexpandtab
	RetabIndent

	let &l:tabstop = tmp
endfunction

"-----------------------
"=== Plugin settings ===
"-----------------------

let g:lion_squeeze_spaces = 1

" " Autocompletion with mucomplete
let g:mucomplete#enable_auto_at_startup = 1
let g:mucomplete#completion_delay = 300
let g:mucomplete#chains = {}
let g:mucomplete#chains.default = ['ulti', 'path', 'omni', 'keyn', 'dict', 'uspl']
set completeopt=menuone,noinsert
set infercase

"" Python-syntax
let g:python_highlight_all = 1

"" Auto-pairs
let g:AutoPairsCompleteOnlyOnSpace = 1

"" vim-signiture
let g:SignatureMap = {
        \ 'Leader'             :  "m",
        \ 'PlaceNextMark'      :  "m,",
        \ 'ToggleMarkAtLine'   :  "m.",
        \ 'PurgeMarksAtLine'   :  "dm-",
        \ 'DeleteMark'         :  "dm",
        \ 'PurgeMarks'         :  "dm/",
        \ 'PurgeMarkers'       :  "dm?",
        \ 'GotoNextLineAlpha'  :  "m<LEADER>",
        \ 'GotoPrevLineAlpha'  :  "",
        \ 'GotoNextSpotAlpha'  :  "m<LEADER>",
        \ 'GotoPrevSpotAlpha'  :  "",
        \ 'GotoNextLineByPos'  :  "",
        \ 'GotoPrevLineByPos'  :  "",
        \ 'GotoNextSpotByPos'  :  "mn",
        \ 'GotoPrevSpotByPos'  :  "mp",
        \ 'GotoNextMarker'     :  "",
        \ 'GotoPrevMarker'     :  "",
        \ 'GotoNextMarkerAny'  :  "",
        \ 'GotoPrevMarkerAny'  :  "",
        \ 'ListLocalMarks'     :  "m/",
        \ 'ListLocalMarkers'   :  "m?"
        \ }

"" UltiSnip
autocmd WinEnter * silent! iunmap <C-s>
autocmd WinEnter * silent! unmap <C-s>
autocmd WinEnter * silent! vunmap <C-s>
let g:UltiSnipsExpandTrigger           = '<C-s>'
let g:UltiSnipsJumpForwardTrigger      = '<C-s>'
let g:UltiSnipsJumpBackwardTrigger     = '<C-w>'
let g:UltiSnipsSnippetDirectories = [$HOME.'/.config/vim/Ultisnips/', 'Ultisnips']

" Lightline plugin get cool triangular font instead of square
" And show open buffers on top, you can swap between buffers with <leader>n
" <leader>p and other keys. look at the mappings!
set laststatus=2
let g:lightline = {
 	\ 'colorscheme':  'dracula',
 	\ 'separator':    { 'left': 'î‚°', 'right': 'î‚²' },
 	\ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' },
      	\ 'active': {
      	\   'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'modified' ] ]
      	\ },
      	\ 'tabline': {
      	\   'left': [ ['buffers'] ],
      	\   'right': [ ['close'] ]
      	\ },
      	\ 'component_expand': {
      	\   'buffers': 'lightline#bufferline#buffers'
      	\ },
      	\ 'component_type': {
      	\   'buffers': 'tabsel'
      	\ }
      	\ }

set showtabline=2
let g:lightline#bufferline#show_number = 2
let g:lightline#bufferline#filename_modifier = ':.'
let g:lightline#bufferline#number_separator = ' '
let g:lightline#bufferline#composed_number_map = {
\ 1:  '#1',  2:  '#2',  3:  '#3',  4:  '#4',  5:  '#5',
\ 6:  '#6',  7:  '#7',  8:  '#8',  9:  '#9',  10: '#10',
\ 11: '#11', 12: '#12', 13: '#13', 14: '#14', 15: '#15',
\ 16: '#16', 17: '#17', 18: '#18', 19: '#19', 20: '#20'}


" Make highligted searches red and highlight column 81 in gray
" augroup dracula-theme-overrides
" 	autocmd!
" 	autocmd ColorScheme dracula highlight Search term=reverse guifg=fg guibg=#BF616A
" 	autocmd ColorScheme dracula highlight IncSearch term=reverse gui=underline guifg=fg guibg=#BF616A
" 	autocmd ColorScheme dracula highlight ColorColumn guibg=#4C566A
" augroup END
call matchadd('ColorColumn', '\%81v',100)

colorscheme dracula
hi Normal guibg=NONE ctermbg=NONE

" Dirvish file viewer
let g:dirvish_mode = 1
let g:dirvish_relative_paths = 0
call dirvish#add_icon_fn({p -> p[-1:]=='/'?'ðŸ“‚':'ðŸ“„'})


"=======================
"=== Global Bindings ===
"=======================

let mapleader=" "

" Swap visual and visual-block
nnoremap v <C-V>
nnoremap <C-v> v

" Better bindings for navigating splits
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
map <leader>q :close<CR>

" Easier saving
map <leader>w :w<CR>

map <leader>f :filetype detect<CR>

" --
" Open files in buffers or splits with fuzzy finding
" --
map <leader>v :vs **/*
map <leader>h :sp **/*
map <leader>e :e **/*

" --
"  Convert camel_case to snake_case
"  --
function CamelCaseToSnakeCase()
	exe "normal :s#\\(\\<\\u\\l\\+\\|\\l\\+\\)\\(\\u\\)#\\l\\1_\\l\\2#g\<CR>"
endfunc
map <leader>sc :call CamelCaseToSnakeCase()<CR>

" --
" Buffer controls with the lightline bufferline plugin
" --
map <leader>cc :bd<CR>

nmap <LEFT> :bprevious<CR>
nmap <RIGHT> :bnext<CR>
nmap <leader>p :bprevious<CR>
nmap <leader>n :bnext<CR>

nmap <Leader>& <Plug>lightline#bufferline#go(1)
nmap <Leader>[ <Plug>lightline#bufferline#go(2)
nmap <Leader>{ <Plug>lightline#bufferline#go(3)
nmap <Leader>} <Plug>lightline#bufferline#go(4)
nmap <Leader>( <Plug>lightline#bufferline#go(5)
nmap <Leader>= <Plug>lightline#bufferline#go(6)
nmap <Leader>* <Plug>lightline#bufferline#go(7)
nmap <Leader>) <Plug>lightline#bufferline#go(8)
nmap <Leader>+ <Plug>lightline#bufferline#go(9)
nmap <Leader>] <Plug>lightline#bufferline#go(10)

nmap <Leader>c& <Plug>lightline#bufferline#delete(1)
nmap <Leader>c[ <Plug>lightline#bufferline#delete(2)
nmap <Leader>c{ <Plug>lightline#bufferline#delete(3)
nmap <Leader>c} <Plug>lightline#bufferline#delete(4)
nmap <Leader>c( <Plug>lightline#bufferline#delete(5)
nmap <Leader>c= <Plug>lightline#bufferline#delete(6)
nmap <Leader>c* <Plug>lightline#bufferline#delete(7)
nmap <Leader>c) <Plug>lightline#bufferline#delete(8)
nmap <Leader>c+ <Plug>lightline#bufferline#delete(9)
nmap <Leader>c] <Plug>lightline#bufferline#delete(10)

" schlepp
vmap <unique> <up>    <Plug>SchleppUp
vmap <unique> <down>  <Plug>SchleppDown
vmap <unique> <left>  <Plug>SchleppLeft
vmap <unique> <right> <Plug>SchleppRight

" SQL Stuff

" Automatically create drop statement at the head of the file for current line
func DropTemplate()
	if getline(".") =~? "TABLE" || getline(".") =~? "VIEW"
		exe "normal 0wy2eggODROP \<Esc>pbiIF EXISTS \<Esc>A;\<Esc><C-o>"
	elseif getline(".") =~? "SEQUENCE"
		exe "normal 0wy2egg}ODROP \<Esc>pbiIF EXISTS \<Esc>A;\<Esc><C-o>"
	endif
endfunc
map <leader>fd :call DropTemplate()<CR>

" Macro to generate sql code from a table template like
" MyTable (Attribute1, Attribute2, Attr3)
func TableTemplate()
	" These strings are basically macros
	let l:TableStruct   = "I\<CR>CREATE TABLE \<Esc>wvEguf(a\<CR>"
	let l:ContentAlign = "0f,i TYPE\<Esc>la\<CR>\<Esc>"
	let l:CallDropTemplate = "?CREATE TABLE \<CR>:call DropTemplate()\<CR>\<C-o>\<C-o>"
	let l:SetPrimaryKey = "OPRIMARY KEY (),\<CR>FOREIGN KEY (attribute) REFERENCES table_name(attribute)\<Esc>j0"
	let l:EndStruct = "a;\<Esc>j"

	exe "normal " .. TableStruct

	while getline('.') =~? ','
		exe "normal " .. ContentAlign
	endwhile
	exe "normal ea TYPE,\<CR>\<CR>\<Esc>"

	exe "normal " CallDropTemplate .. SetPrimaryKey .. EndStruct
endfunc
map <leader>ft :call TableTemplate()<CR>

" Take table data and format it for an sql insert
" This quotes integers and dates too because vimscript sucks
func InsertTemplate()
	let l:Clean = "O\<Esc>j}o\<Esc>{j"
	let l:InsertStruct = "OINSERT INTO table_name(attr1,attr2,...) VALUES\<Esc>j"
	let l:LineStruct = "A)\<Esc>I(\<Esc>w"
	let l:ContentStruct = "vt S'f r,w"
	let l:EndStruct = "kA\<Esc>r;\<CR>"

	exe "normal " .. Clean .. InsertStruct

	while getline(".") !~ '^$'
		exe "normal " .. LineStruct
		while getline(".") =~? " "
			exe "normal " .. ContentStruct
		endwhile
		exe "normal vEhS'A,\<Esc>j"
	endwhile
	exe "normal " .. EndStruct
endfunc
map <leader>fi :call InsertTemplate()<CR>

" Fix formatting of data that had spaces in it
func FixInsertValue()
	let l:Fix = "f'vf'c \<Esc>F'"
	exe "normal " .. Fix
endfunc
map <leader>ff :call FixInsertValue()<CR>

" --
" FZF
" --

" Finding Files with FZF
nnoremap <silent> <C-f> :Files<CR>

" Finding in Files with ripgrep
nnoremap <silent> <Leader>f :Rg<CR>

" Open buffers
nnoremap <silent> <Leader>b :Buffers<CR>

" Lines in the current buffers
nnoremap <silent> <Leader>/ :BLines<CR>

" Marks in different files
nnoremap <silent> <Leader>' :Marks<CR>

nnoremap <silent> <Leader>H :Helptags<CR>

" v:oldfiles and open buffers
" history of files(h)
nnoremap <silent> <Leader>hh :History<CR>
" Command history
"history of command(:)
nnoremap <silent> <Leader>h: :History:<CR>
" Search history
"history of search(/)
nnoremap <silent> <Leader>h/ :History/<CR>


" --
" TOGGLES
" --

" undotree
map <leader>u :UndotreeToggle<CR>

" Disable highlight search
map <silent> <leader><leader> :noh<CR>

" Look at folding settings
map <silent> <leader>o :call ToggleOverview()<CR>

" Toggle ro to avoid editing a file
map <leader>r :call ToggleReadonly()<CR>
function ToggleReadonly()
	if &readonly == 1
		let &readonly=0
	else
		let &readonly=1
	endif
endfunction

" Toggle spellcheck
map <leader>s :setlocal spell!<CR>

" (centered text plugin)
map <leader>g :Goyo<CR>


" Compile function
map <leader>m :call CompileRunGcc()<CR>
func! CompileRunGcc()
  exec "w"
  if &filetype == 'c'
	exec "!g++ -Wpedantic -O3 %:p -o %:p:r.out && %:p:r.out"
  elseif &filetype == 'cpp'
	exec "!g++ -Wpedantic -O3 %:p -o %:p:r.out && %:p:r.out"
  elseif &filetype == 'java'
    exec "!javac %"
    exec "!time java %<"
  elseif &filetype == 'sh'
    :!time bash %
  elseif &filetype == 'python'
    silent! exec "!clear"
    exec "!time python3 %"
  elseif &filetype == 'html'
    exec "!firefox %:p:s?/home/\\w\\+?localhost? &"
  elseif &filetype == 'javascript'
    exec "!firefox %:p:s?/home/\\w\\+?localhost?:r.html &"
  elseif &filetype == 'php'
    exec "!firefox %:p:s?/home/\\w\\+?localhost?:r.html &"
  elseif &filetype == 'markdown'
    exec "MarkdownPreview"
  endif
endfunc

"====================================================
"=== Some autoexec commands and filetype bindings ===
"====================================================

if has('autocmd')
	autocmd FileType tex,latex,markdown setlocal spell! | setlocal fp="fmt -w80"

	autocmd FileType html,css setlocal tabstop=4

	autocmd FileType python,sh set foldmethod=indent


	autocmd BufNewFile,BufRead * if empty(&filetype) | setlocal fp="fmt -w80" | endif

	autocmd BufWritePre *.sql silent %s/\<\w\+\>/\=synIDattr(synID(line('.'),col('.'),1), 'name')=~?'sql\%(keyword\|operator\|statement\|type\|function\)'?toupper(submatch(0)):submatch(0)/g |''

	autocmd BufWritePre * %s/\s\+$//e " Remove trailing spaces

else
	echom "This build does not support autocmds"

	augroup pencil
	  autocmd!
	  autocmd FileType markdown,mkd call pencil#init()
	  autocmd FileType text         call pencil#init() | execute silent :Goyo<CR>
	augroup END
endif
